# QM Verbs

```elixir
Mix.install([
  {:kino, "~> 0.14.0"},
  {:elixir_xml_to_map, "~> 3.1"}
])
```

## Code

```elixir
defmodule QM do
  @qm "/Users/lenz/dev/QueueMetrics"
  @qmpages_at "#{@qm}/src/main/webapp/"
  @qmclasses_at "#{@qm}/src/main/java/"
  @qmjs_at "#{@qm}/nodejs/modules/"

  def all_verbs(qmverbs_at) do
    qmverbs_at
    |> Path.join("**/*.xml")
    |> Path.wildcard()
    |> Enum.map(&read_verb/1)
  end

  def read_verb(filename) do
    xml =
      filename
      |> File.read!()
      |> XmlToMap.naive_map()

    %{
      verb: xml["verbo"]["nome"],
      classes: classes(xml["verbo"]["classi"]),
      destinations: destinations(xml["verbo"]["destinazione"]),
      sources: []
    }
  end

  defp classes(%{"c" => nil}), do: []
  defp classes(nil), do: []
  defp classes(%{"c" => v}) when is_list(v), do: classes(v)

  defp classes(%{"c" => v}) when is_binary(v), do: classes([v])

  defp classes(l_classes) when is_list(l_classes) do
    l_classes
    |> Enum.map(fn c ->
      %{name: shorten_java_class(c), extra: ""}
    end)
  end

  defp destinations(nil), do: []

  defp destinations(%{} = m) do
    m
    |> Enum.map(fn {k, v} ->
      kk =
        case k do
          "DEFAULT" -> ""
          _ -> k
        end

      vv =
        v
        |> String.replace("$WEBAPP/", "")
        |> String.replace("?", "-")
        |> String.replace("=", "-")
      

      vvv =
        case String.ends_with?(vv, ".do") do
          true -> String.replace(vv, ".do", "")
          _ -> vv
        end

      %{page: vvv, extra: "", link: kk}
    end)
    |> Enum.filter(fn %{page: p} -> p not in ["na", "n/a", "qm/svc_json_reply.jsp"] end)
  end

  @doc """
  Aggiunge le info che NON sono nel verbo.

  - numero di altri verbi che condividono la stessa destinazone
  - numero di altri verbi che condividono le calssi
  - link al verbo da JSP JSm e Java

  """
  def enhance(
        %{verb: verb, classes: local_classes, destinations: local_destinations} = a_verb,
        verb_db
      ) do
    all_classes =
      verb_db
      |> Enum.map(fn %{classes: c} -> c end)
      |> List.flatten()
      |> Enum.map(fn %{name: n} -> n end)
      |> Enum.frequencies()

    all_destinations =
      verb_db
      |> Enum.map(fn %{destinations: c} -> c end)
      |> List.flatten()
      |> Enum.map(fn %{page: n} -> n end)
      |> Enum.frequencies()

    classes_with_extra =
      local_classes
      |> Enum.map(fn %{name: name} = local_class ->
        x =
          case Map.get(all_classes, name) do
            nil -> ""
            1 -> ""
            v -> "+#{v - 1}"
          end

        %{local_class | extra: x}
      end)

    destinations_with_extras =
      local_destinations
      |> Enum.map(fn %{page: page} = local_destination ->
        x =
          case Map.get(all_destinations, page) do
            nil -> ""
            1 -> ""
            v -> "+#{v - 1}"
          end

        %{local_destination | extra: x}
      end)

    sources = find_sources(verb)

    %{
      a_verb
      | classes: classes_with_extra,
        destinations: destinations_with_extras,
        sources: sources
    }
  end

  def find_sources(verb),
    do: find_source_pages(verb) ++ find_source_classes(verb) ++ find_source_js(verb)

  def find_source_pages(verb), do: find_files_containing(@qmpages_at, "**/*.jsp", verb, :page)
  def find_source_js(verb), do: find_files_containing(@qmjs_at, "**/*.js", verb, :js)

  def find_source_classes(verb),
    do: find_files_containing(@qmclasses_at, "**/*.java", verb, :class)

  def find_files_containing(from, filetype, verb, type) do
    from
    |> Path.join(filetype)
    |> Path.wildcard()
    |> Enum.filter(fn f ->
      File.read!(f)
      |> contains_verb?(verb)
    end)
    |> Enum.map(fn p -> %{type: type, src: cleanup_filename(p)} end)
  end

  defp contains_verb?(page, verb) do
    page
    |> String.downcase()
    |> String.contains?(["'#{verb}'", "\"#{verb}\"", "#{verb}.do"])
  end

  def cleanup_filename(p) do
    if String.contains?(p, ".java") do
      p
      |> String.replace(@qmclasses_at, "")
      |> String.replace("/", ".")
      |> String.replace(".java", "")
      |> shorten_java_class()
    else
      p
      |> String.replace(@qmpages_at, "")
      |> String.replace(@qmjs_at, "")
    end
  end

  defp shorten_java_class(c),
    do:
      c
      |> String.replace("it.loway.app.queuemetrics.", "")
      |> String.replace("ch.loway.app.queuemetrics.", "")

  def mrm_verb(%{verb: v, classes: c, destinations: d, sources: s}) do
    """

    subgraph #{v}
      #{mrm_class(v, c)}  
    end

    #{Enum.map(d, fn %{page: page, extra: x} -> mrm_page(page, x) end)}

    #{Enum.map(d, fn %{page: page, link: link} -> "#{v} -- #{link} --> #{page}\n" end)}

    #{Enum.map(s, fn %{type: _t, src: src} -> "#{src} --> #{v}\n" end)}

    """
  end

  def mrm_verb(_other), do: ""

  defp mrm_page(page, extra), do: "#{page}([#{page} #{extra}])\n"

  defp mrm_class(verb, %{name: name, extra: extra}), do: "#{verb}_#{name}([#{name} #{extra}])\n"

  defp mrm_class(v, l) when is_list(l) do
    l
    |> Enum.map(fn c -> mrm_class(v, c) end)
    |> Enum.join(" --> ")
  end

  def as_mermaid(graphs) when is_list(graphs), do: as_mermaid(Enum.join(graphs, "\n\n"))

  def as_mermaid(text) when is_binary(text) do
    Kino.Mermaid.new("""
    flowchart LR

    #{text}

    """)
  end

  def as_mermaid_(t), do: IO.puts(t)
end

all_verbs = QM.all_verbs("/Users/lenz/dev/QueueMetrics/src/main/webapp/WEB-INF/LVerbs")

all_verbs
|> Enum.take(2)
|> Enum.map(fn v -> QM.enhance(v, all_verbs) end)
|> Enum.map(fn v -> QM.mrm_verb(v) end)
|> QM.as_mermaid()

# QM.read_verb("/Users/lenz/dev/QueueMetrics/src/main/webapp/WEB-INF/LVerbs/direct_link/drep.xml")
```

```elixir
defmodule P do
  def list_contains_hints(l, lHints) do
    lc_l = Enum.map(l, &String.downcase/1)
    lc_hints = Enum.map(lHints, &String.downcase/1)
    
    for v <- lc_l, h <- lc_hints do
      String.contains?(v, h)
    end
    |> Enum.find(false, fn v -> v end)
  end

  def enhance_and_plot(all_verbs, my_verbs) do
    my_verbs
    |> Enum.map(fn v -> QM.enhance(v, all_verbs) end)
    |> Enum.map(fn v -> QM.mrm_verb(v) end)
    |> QM.as_mermaid()
  end

  def with_destinations(all_verbs, l_page_hints)
      when is_list(all_verbs) and is_list(l_page_hints) do
    my_verbs =
      all_verbs
      |> Enum.filter(fn %{destinations: lp} ->
        page_names = Enum.map(lp, fn %{page: p} -> p end)
        list_contains_hints(page_names, l_page_hints)
      end)

    enhance_and_plot(all_verbs, my_verbs)
  end

  def with_verb(all_verbs, l_verb_hints) when is_list(all_verbs) and is_list(l_verb_hints) do
    my_verbs =
      all_verbs
      |> Enum.filter(fn %{verb: v} ->
        list_contains_hints([v], l_verb_hints)
      end)

    enhance_and_plot(all_verbs, my_verbs)
  end

  def with_class(all_verbs, l_class_hints) when is_list(all_verbs) and is_list(l_class_hints) do
    my_verbs =
      all_verbs
      |> Enum.filter(fn %{classes: lp} ->
        page_names = Enum.map(lp, fn %{name: p} -> p end)
        list_contains_hints(page_names, l_class_hints)
      end)


    enhance_and_plot(all_verbs, my_verbs)
  end
  
end

# P.with_destinations(all_verbs, ["qm_drep"])
# P.with_verb(all_verbs, ["dre"])
P.with_class(all_verbs, ["directinner"])
```

### AFP_

```elixir
P.with_destinations(all_verbs, ["afp"])
```

### Bug 6871 - Remove "afp_" popups

```elixir
P.with_destinations(all_verbs, [
  "custom_report",
  "afp_skeleton.jsp",
  "custom_report.jsp",
  "qm_recordtag_list.jsp"
])
```

```elixir
P.with_destinations(all_verbs, [
  "popup_audiomon.jsp",
  "popup_call_close.jsp",
  "popup_call.jsp",
  
])
```

```elixir
P.with_destinations(all_verbs, [
  "qm_taskslist.jsp",
  "qm_tasksearch.jsp",
  "qm_taskdetail",
  "qm_taskreport_detail"
])
```

```elixir
P.with_verb(all_verbs, ["qm_task_"])
```

```elixir
P.with_destinations(all_verbs, [
  "popup_qa_grade_ajx.jsp",
  "popup_qa_addComment_ajx_ds"
])
```

## Esempi

Alcuni esempi

```mermaid
flowchart TD

subgraph qm_start
  qm_start_autenticazione.start([autenticazione.start +11])
  
end

dbtest/expired_license.jsp([dbtest/expired_license.jsp ])
licence_agreement.jsp([licence_agreement.jsp +1])
qm_start2([qm_start2 +1])


qm_start -- DBTEST --> dbtest/index.jsp-exception-1
qm_start -- EXPKEY --> dbtest/expired_license.jsp
qm_start -- LICENZA --> licence_agreement.jsp
qm_start -- default --> qm_start2




```

```elixir
Kino.Mermaid.new("""

graph LR
    A[Square Rect] -- Link text --> B((Circle))
    A --> C(Round Rect)
    B --> D{Rhombus}
    C --> D

""")
```

```elixir
qm = "/Users/lenz/dev/QueueMetrics"
qmverbs_at = "#{qm}/src/main/webapp/WEB-INF/LVerbs/"
qmclass = ""
qmpages_at = "#{qm}/src/main/webapp/"


allverbs = qmverbs_at
|> Path.join("**/*.xml")
|> Path.wildcard()

verb =List.first(allverbs, "")
XmlToMap.naive_map(File.read!(verb))

```

```elixir
qmpages_at
|> Path.join("**/*.jsp")
|> Path.wildcard()
|> Enum.filter( fn f -> 
  File.read!(f)
  |> String.downcase()
  |> String.contains?("qm_start.do")
end)
```
