# QM Verbs

```elixir
Mix.install([
  {:kino, "~> 0.14.0"},
  {:elixir_xml_to_map, "~> 3.1"}
])
```

## Code

```elixir
defmodule QM do
  @qm  "/Users/lenz/dev/QueueMetrics"
  @qmpages_at  "#{@qm}/src/main/webapp/"
  @qmclasses_at "#{@qm}/src/main/java/"
  
  def all_verbs(qmverbs_at) do
    qmverbs_at
    |> Path.join("**/*.xml")
    |> Path.wildcard()
    |> Enum.map(&read_verb/1)
  end

  def read_verb(filename) do
    xml =
      filename
      |> File.read!()
      |> XmlToMap.naive_map()

    %{
      verb: xml["verbo"]["nome"],
      classes: classes(xml["verbo"]["classi"]),
      destinations: destinations(xml["verbo"]["destinazione"]),
      sources: []
    }
  end

  defp classes(%{"c" => nil}), do: []
  defp classes(nil), do: []
  defp classes(%{"c" => v}) when is_list(v), do: classes(v)

  defp classes(%{"c" => v}) when is_binary(v), do: classes([v])

  defp classes(l_classes) when is_list(l_classes) do
    l_classes
    |> Enum.map(fn c ->
      
      %{name: java_class(c), extra: ""}
    end)
  end

  defp destinations(nil), do: []

  defp destinations(%{} = m) do
    m
    |> Enum.map(fn {k, v} ->
      kk =
        case k do
          "DEFAULT" -> ""
          _ -> k
        end

      vv =
        v
        |> String.replace("$WEBAPP/", "")

      vvv =
        case String.ends_with?(vv, ".do") do
          true -> String.replace(vv, ".do", "")
          _ -> vv
        end

      

      
      %{page: vvv, extra: "", link: kk}
    end)
    |> Enum.filter(fn %{page: p} -> p not in ["na", "n/a", "qm/svc_json_reply.jsp"] end)
  end

  def enhance(
        %{verb: verb, classes: local_classes, destinations: local_destinations} = a_verb,
        verb_db
      ) do
    all_classes =
      verb_db
      |> Enum.map(fn %{classes: c} -> c end)
      |> List.flatten()
      |> Enum.map(fn %{name: n} -> n end)
      |> Enum.frequencies()

    all_destinations =
      verb_db
      |> Enum.map(fn %{destinations: c} -> c end)
      |> List.flatten()
      |> Enum.map(fn %{page: n} -> n end)
      |> Enum.frequencies()

    classes_with_extra =
      local_classes
      |> Enum.map(fn %{name: name} = local_class ->
        x =
          case Map.get(all_classes, name) do
            nil -> ""
            1 -> ""
            v -> "+#{v - 1}"
          end

        %{local_class | extra: x}
      end)

    destinations_with_extras =
      local_destinations
      |> Enum.map(fn %{page: page} = local_destination ->
        x =
          case Map.get(all_destinations, page) do
            nil -> ""
            1 -> ""
            v -> "+#{v - 1}"
          end

        %{local_destination | extra: x}
      end)

    sources = find_sources(verb)

    %{
      a_verb
      | classes: classes_with_extra,
        destinations: destinations_with_extras,
        sources: sources
    }
  end

  def find_sources(verb), do:    find_source_pages(verb) ++ find_source_classes(verb)
  

  def find_source_pages(verb), do: find_files_containing( @qmpages_at, "**/*.jsp",  verb, :page )

  
  def find_source_classes(verb), do: find_files_containing( @qmclasses_at, "**/*.java",  verb, :class )

    

  def find_files_containing(from, filetype, verb, type) do
    
    from
    |> Path.join(filetype)
    |> Path.wildcard()
    |> Enum.filter(fn f ->
      File.read!(f)
      |> contains_verb?(verb)
    end)
    
    |> Enum.map(fn p -> %{type: type, src: cleanup_filename(p)} end)
  end  

  defp contains_verb?(page, verb) do
    page
    |> String.downcase()
    |> String.contains?(["'#{verb}'", "\"#{verb}\"", "#{verb}.do"])
  end

  def cleanup_filename(p) do
    if String.contains?(p, ".java") do
    p
    |> String.replace(@qmclasses_at, "")
    |> String.replace("/", ".")  
    |> String.replace(".java", "")
    |> java_class()
      
    else
    p
    |> String.replace(@qmpages_at, "")
    |> String.replace(".jsp", "")
    

      
    end

    

    
  end

  defp java_class(c), do:  c
        |> String.replace("it.loway.app.queuemetrics.", "")
        |> String.replace("ch.loway.app.queuemetrics.", "")


  
  def mrm_verb(%{verb: v, classes: c, destinations: d, sources: s}) do
    """

    subgraph #{v}
      #{mrm_class(v, c)}  
    end

    #{Enum.map(d, fn %{page: page, extra: x} -> mrm_page(page, x) end)}

    #{Enum.map(d, fn %{page: page, link: link} -> "#{v} -- #{link} --> #{page}\n" end)}

    #{Enum.map(s, fn %{type: _t, src: src} -> "#{src} --> #{v}\n" end)}
    
    """
  end

  def mrm_verb(_other), do: ""

  defp mrm_page(page, extra), do: "#{page}([#{page} #{extra}])\n"

  defp mrm_class(verb, %{name: name, extra: extra}), do: "#{verb}_#{name}([#{name} #{extra}])\n"

  defp mrm_class(v, l) when is_list(l) do
    l
    |> Enum.map(fn c -> mrm_class(v, c) end)
    |> Enum.join(" --> ")
  end

  def as_mermaid(graphs) when is_list(graphs), do: as_mermaid(Enum.join(graphs, "\n\n"))

  def as_mermaid(text) when is_binary(text) do
    Kino.Mermaid.new("""
    flowchart LR

    #{text}

    """)

    
  end

  def as_mermaid_(t), do: IO.puts(t)
  
end

all_verbs = QM.all_verbs("/Users/lenz/dev/QueueMetrics/src/main/webapp/WEB-INF/LVerbs")

all_verbs
|> Enum.take(10)
|> Enum.map(fn v -> QM.enhance(v, all_verbs) end)
|> Enum.map(fn v -> QM.mrm_verb(v) end)
|> QM.as_mermaid()

# QM.read_verb("/Users/lenz/dev/QueueMetrics/src/main/webapp/WEB-INF/LVerbs/direct_link/drep.xml")
```

```elixir
defmodule P do
  def list_contains_hints(l, lHints) do
    lc_l = Enum.map(l, &String.downcase/1)
    lc_hints = Enum.map(lHints, &String.downcase/1)
    
    for v <- lc_l, h <- lc_hints do
      String.contains?(v, h)
    end
    |> Enum.find(false, fn v -> v end)
  end

  def enhance_and_plot(all_verbs, my_verbs) do
    my_verbs
    |> Enum.map(fn v -> QM.enhance(v, all_verbs) end)
    |> Enum.map(fn v -> QM.mrm_verb(v) end)
    |> QM.as_mermaid()
  end

  def with_destinations(all_verbs, l_page_hints)
      when is_list(all_verbs) and is_list(l_page_hints) do
    my_verbs =
      all_verbs
      |> Enum.filter(fn %{destinations: lp} ->
        page_names = Enum.map(lp, fn %{page: p} -> p end)
        list_contains_hints(page_names, l_page_hints)
      end)

    enhance_and_plot(all_verbs, my_verbs)
  end

  def with_verb(all_verbs, l_verb_hints) when is_list(all_verbs) and is_list(l_verb_hints) do
    my_verbs =
      all_verbs
      |> Enum.filter(fn %{verb: v} ->
        list_contains_hints([v], l_verb_hints)
      end)

    enhance_and_plot(all_verbs, my_verbs)
  end

  def with_class(all_verbs, l_class_hints) when is_list(all_verbs) and is_list(l_class_hints) do
    my_verbs =
      all_verbs
      |> Enum.filter(fn %{classes: lp} ->
        page_names = Enum.map(lp, fn %{name: p} -> p end)
        list_contains_hints(page_names, l_class_hints)
      end)


    enhance_and_plot(all_verbs, my_verbs)
  end
  
end

# P.with_destinations(all_verbs, ["qm_drep"])
# P.with_verb(all_verbs, ["dre"])
P.with_class(all_verbs, ["directinner"])
```

## Logic

prova

```mermaid

flowchart TD


subgraph drep
  it.loway.app.queuemetrics.autenticazione.directInnerLink([it.loway.app.queuemetrics.autenticazione.directInnerLink])
  
end

AUTH([AUTH])
NOAUTH([NOAUTH])
default([default])


drep --> $WEBAPP/qm_drep_process.do
drep --> $WEBAPP/qm_start.do
drep --> na






```

```mermaid
flowchart TD

subgraph drep
  it.loway.app.queuemetrics.autenticazione.directInnerLink([it.loway.app.queuemetrics.autenticazione.directInnerLink])
  
end

AUTH([AUTH])
NOAUTH([NOAUTH])
default([default])


drep --> $WEBAPP/qm_drep_process.do
drep --> $WEBAPP/qm_start.do
drep --> na





```

```mermaid
pie title NETFLIX
         "Time spent looking for movie" : 90
         "Time spent watching it" : 10
```

```elixir
Kino.Mermaid.new("""

graph LR
    A[Square Rect] -- Link text --> B((Circle))
    A --> C(Round Rect)
    B --> D{Rhombus}
    C --> D

""")
```

```elixir
qm = "/Users/lenz/dev/QueueMetrics"
qmverbs_at = "#{qm}/src/main/webapp/WEB-INF/LVerbs/"
qmclass = ""
qmpages_at = "#{qm}/src/main/webapp/"


allverbs = qmverbs_at
|> Path.join("**/*.xml")
|> Path.wildcard()

verb =List.first(allverbs, "")
XmlToMap.naive_map(File.read!(verb))

```

```elixir
qmpages_at
|> Path.join("**/*.jsp")
|> Path.wildcard()
|> Enum.filter( fn f -> 
  File.read!(f)
  |> String.downcase()
  |> String.contains?("qm_start.do")
end)
```
